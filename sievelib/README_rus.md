# sievelib - статическая библиотека для вычисления простого числа с помощью решета Эратосфена

Библиотека состоит из двух файлов:
* `libsieve.a`	- объектный файл
* `sievelib.h`	- заголовочный файл библиотеки

Также проект содержит папки:

* `scripts/`	- скрипты для автоматизации процесса разработки и отладки библиотеки:
    - `create_static_lib`   - скрипт для создания статической библиотеки;
    - `file_stat_lib_run`   - скрипт для компиляции файла со статической библиотекой и его запуска;
    - `run_tests`           - перекомпиляция тестовых файлов и их запуск. 

* `sourse/`	- содержит файл с исходным кодом функций библиотеки;

* `tests/` 	- тесты для проверки работоспособности библиотеки:
    - `malloc_free_test.c`  - тест для проверки работы функций `sieve_init_malloc()` и `sieve_free()`;
    - `next_prime_test.c`   - тест для проверки работоспособности функции `sieve_get_next_prime()`; 
    - `push_test.c`         - тест функции `sieve_push_prime()`.
    

## sievelib.h

В этом заголовочном файле описаны структуры данных и прототипы (объявления) всех функций, содержащихся в библиотеке.

С помощью конструкции:
```
#ifndef SIEVE
#define SIEVE
#endif
```
... файл защищен от повторного включения.

Подключаемые заголовочные файлы позволяют работать с функциями printf(), malloc(), assert() и использовать тип bool.

Файл `"timerlib.h"` cодержит функции:
* `sieve_t* sieve_init_malloc(int)`		    - выделяет память под структуру "решето" заданного размера, заполняет все поля нулями, возвращает указатель на структуру;
* `bool sieve_free(sieve_t*)`			    - освобождает выделенную под структуру память;
* `bool sieve_push_prime(sieve_t*, int)`    - вносит простое число в структуру, отмечает все составные до конца массива;
* `int sieve_get_next_prime(sieve_t* )`	    - возвращает значение следующего простого числа.


## scripts/
Скрипты для автоматизации отладки программы

### create_static_lib
Используется для создания статической библиотеки.

При вызове принимает имя библиотеки без указания расширения файла и суффикса `lib` (например, `sievelib.c` сокращаем до `sieve`):

`./create_static_lib sieve`

Далее он самостоятельно создает библиотеку `libsieve.a` и удаляет временные файлы.

### file_stat_lib_run
Скрипт для компиляции файла со статической библиотекой и его запуска.

Как аргументы скрипт принимает название компилируемого файла и библиотеки. Название файлов писать без расширения и префикса `lib`. Например, `libsieve.a` сокращается до`sieve`, а `test.c` - до `test`.

`./file_stat_lib_run test sieve` 

Скрипт перекомпилирует тестовый файл, запускает его:

`./test`

...после чего удаляет исполняемый и все временный файлы.


### run_tests
Скрипт служит для перекомпиляции и запуска всех тестовых файлов сразу. Содержит список вызываемых тестов.

Запускается командой:

`./run_tests`

### Использование скриптов

После каждого внесения изменений в код библиотеки, перекомпилируем ее:

`./create_static_lib sieve`

... и запускаем тесты:

`./run_tests`
 

## Создание статической библиотеки (без использования скриптов)

Все действия выполняем в каталоге `sievelib/`.

Получаем объектный файл библиотеки:

`gcc -c ./source/sievelib.c`

В каталоге `sievelib/` должен появиться файл `sievelib.o`.

Создаем статическую библиотеку с помощью утилиты **ar**:

`ar r libsieve.a sievelib.o`
* `r`           - позволяет вставить файлы в архив, если архива нет, то он создается;
* `libsieve.a`  - имя создаваемого архива, в операционных системах GNU/Linux должно иметь префикс **lib** и расширение **.a**;
* `libsieve.o`  - файл из которого создается архив.

Объектный файл можно удалить:

`rm libsieve.o`

Содержимое каталога в итоге должно содержать:
```
libsieve.a  - статическая библиотека
sievelib.h  - заголовочный файл библиотеки
source/     - папка с исходным кодом функций библиотеки (для работы не нужна, можно и удалить)
```


## Использование библиотеки в программе 
В данном случае компилируем с библиотекой файлы из каталога `tests/`.

Все действия выполняем в каталоге `sievelib/`.

Получаем объектный файл из тестового файла:

`gcc -c tests/push_test.c`

В каталоге `sievelib/` должен появиться файл `push_test.o`.

Компилируем его с библиотекой:

`gcc -o push_test push_test.o -L. -lsieve` 
* `-o push_test`- компилируется исполняемый файл `push_test`;
* `push_test.o` - из объектного файла;
* `-L.`         - после **-L** пишем адрес каталога, где находится библиотека (**.** - текущий каталог);
* `-lsieve`     - после **-l** пишется имя библиотеки без префикса **lib** и суффикса **.a**.

В каталоге `sievelib` появляется исполняемый файл `push_test`, который можно запустить командой:

`./push_test`


