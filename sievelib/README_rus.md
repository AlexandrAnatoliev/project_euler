# sievelib - статическая и динамическая библиотека для вычисления простого числа с помощью решета Эратосфена

Библиотека состоит из файлов:
* `libsieve_stat.a` - объектный файл статической библиотеки;
* `libsieve_dyn.so` - объектный файл динамической библиотеки;
* `sievelib.h`      - заголовочный файл библиотеки.

Также проект содержит папки:

* `scripts/`    - скрипты для автоматизации процесса разработки и отладки библиотеки:
    - `create_static_lib`   - скрипт для создания статической библиотеки;
    - `file_stat_lib_run`   - скрипт для компиляции файла со статической библиотекой и его запуска;
    - `run_tests_stat`      - перекомпиляция тестовых файлов статической библиотеки и их запуск. 
    - `create_dynamic_lib`  - скрипт для создания динамической библиотеки;
    - `file_dyn_lib_run`    - скрипт для компиляции файла с динамической библиотекой и его запуска;
    - `run_tests_dyn`       - перекомпиляция тестовых файлов динамической библиотеки и их запуск. 

* `sourse/` - содержит файл с исходным кодом функций библиотеки;

* `tests/`  - тесты для проверки работоспособности библиотеки:
    - `malloc_free_test.c`  - тест для проверки работы функций `sieve_init_malloc()` и `sieve_free()`;
    - `next_prime_test.c`   - тест для проверки работоспособности функции `sieve_get_next_prime()`; 
    - `push_test.c`         - тест функции `sieve_push_prime()`.
    

## sievelib.h

В этом заголовочном файле описаны структуры данных и прототипы (объявления) всех функций, содержащихся в библиотеке.

С помощью конструкции:
```
#ifndef SIEVE
#define SIEVE
#endif
```
... файл защищен от повторного включения.

Подключаемые заголовочные файлы позволяют работать с функциями printf(), malloc(), assert() и использовать тип bool.

Файл `"timerlib.h"` cодержит функции:
* `sieve_t* sieve_init_malloc(int)`     - выделяет память под структуру "решето" заданного размера, заполняет все поля нулями, возвращает указатель на структуру;
* `bool sieve_free(sieve_t*)`           - освобождает выделенную под структуру память;
* `bool sieve_push_prime(sieve_t*, int)`- вносит простое число в структуру, отмечает все составные до конца массива;
* `int sieve_get_next_prime(sieve_t* )` - возвращает значение следующего простого числа.


## scripts/
Скрипты для автоматизации отладки программы


### create_static_lib
Используется для создания статической библиотеки.

При вызове принимает имя библиотеки без указания расширения файла и суффикса `lib` (например, `sievelib.c` сокращаем до `sieve`):

`./create_static_lib sieve`

Далее он самостоятельно создает библиотеку `libsieve_stat.a` и удаляет временные файлы.


### file_stat_lib_run
Скрипт для компиляции файла со статической библиотекой и его запуска.

Как аргументы скрипт принимает название компилируемого файла и библиотеки. Название файлов писать без расширения и префикса `lib`. Например, `libsieve_stat.a` сокращается до`sieve_stat`, а `test.c` - до `test`.

`./rile_stat_lib_run test sieve_stat` 

Скрипт перекомпилирует тестовый файл, запускает его:

`./test`

...после чего удаляет исполняемый и все временный файлы.


### run_tests_stat
Скрипт служит для перекомпиляции и запуска всех тестовых файлов статической библиотеки сразу. Содержит список вызываемых тестов.

Запускается командой:

`./run_tests_stat`


### Использование скриптов

После каждого внесения изменений в код библиотеки, перекомпилируем ее:

`./create_static_lib sieve`

... и запускаем тесты:

`./run_tests_stat`


### create_dynamic_lib
Используется для создания динамической библиотеки.

При вызове принимает имя библиотеки без указания расширения файла и суффикса `lib` (например, `sievelib.c` сокращаем до `sieve`):

`./create_dynamic_lib sieve`

Далее он самостоятельно создает библиотеку `libsieve_dyn.so` и удаляет временные файлы.


### file_dyn_lib_run
Скрипт для компиляции файла с динамической библиотекой и его запуска.

Как аргументы скрипт принимает название компилируемого файла и библиотеки. Название файлов писать без расширения и префикса `lib`. Например, `libsieve_dyn.so` сокращается до`sieve_dyn`, а `test.c` - до `test`.

`./file_dyn_lib_run test sieve_dyn` 

Скрипт перекомпилирует тестовый файл, запускает его:

`./test`

...после чего удаляет исполняемый и все временный файлы.


### run_tests_dyn
Скрипт служит для перекомпиляции и запуска всех тестовых файлов диамической библиотеки сразу. Содержит список вызываемых тестов.

Запускается командой:

`./run_tests_dyn`


### Использование скриптов

После каждого внесения изменений в код библиотеки, перекомпилируем ее:

`./create_dyn_lib sieve`

... и запускаем тесты:

`./run_tests_dyn`
 

## Создание статической библиотеки (без использования скриптов)

Все действия выполняем в каталоге `sievelib/`.

Получаем объектный файл библиотеки:

`gcc -c ./source/sievelib.c`

В каталоге `sievelib/` должен появиться файл `sievelib.o`.

Создаем статическую библиотеку с помощью утилиты **ar**:

`ar r libsieve_stat.a sievelib.o`
* `r`               - позволяет вставить файлы в архив, если архива нет, то он создается;
* `libsieve_stat.a` - имя создаваемого архива, в операционных системах GNU/Linux должно иметь префикс **lib** и расширение **.a**;
* `libsieve.o`      - файл из которого создается архив.

Объектный файл можно удалить:

`rm libsieve.o`

Содержимое каталога в итоге должно содержать:
```
libsieve_stat.a // статическая библиотека
sievelib.h      // заголовочный файл библиотеки
source/         // папка с исходным кодом функций библиотеки (для работы не нужна, можно и удалить)
```


## Использование статической библиотеки в программе 
В данном случае компилируем с библиотекой файлы из каталога `tests/`.

Все действия выполняем в каталоге `sievelib/`.

Получаем объектный файл из тестового файла:

`gcc -c tests/push_test.c`

В каталоге `sievelib/` должен появиться файл `push_test.o`.

Компилируем его с библиотекой:

`gcc -o push_test push_test.o -L.. -lsieve_stat` 
* `-o push_test`- компилируется исполняемый файл `push_test`;
* `push_test.o` - из объектного файла;
* `-L..`        - после **-L** пишем адрес каталога, где находится библиотека (**..** - вышестоящий каталог);
* `-lsieve_stat`- после **-l** пишется имя библиотеки без префикса **lib** и суффикса **.a**.

В каталоге `sievelib` появляется исполняемый файл `push_test`, который можно запустить командой:

`./push_test`


## Создание динамической библиотеки (без использования скриптов)

Все действия выполняем в каталоге `sievelib/`.

Получаем объектный файл библиотеки (используем флаг **-fPIC**):

`gcc -c -fPIC ./source/sievelib.c`

В каталоге `sievelib/` должен появиться файл `sievelib.o`.

Создаем динамическую библиотеку с помощью **gcc**, указав опцию **-shared**:

`gcc -shared -o libsieve_dyn.so sievelib.o`

Объектный файл можно удалить:

`rm libsieve.o`

Содержимое каталога в итоге должно содержать:
```
libsieve_dyn.so // динамическая библиотека
sievelib.h      // заголовочный файл библиотеки
source/         // папка с исходным кодом функций библиотеки (для работы не нужна, можно и удалить)
```


## Использование динамической библиотеки в программе 
В данном случае компилируем с библиотекой файлы из каталога `tests/`.

Все действия выполняем в каталоге `sievelib/`.

Получаем объектный файл из тестового файла:

`gcc -c tests/push_test.c`

В каталоге `sievelib/` должен появиться файл `push_test.o`.

Компилируем его с библиотекой:

`gcc -o push_test push_test.o -L.. -lsieve_dyn -Wl,-rpath,..`
* `-o push_test`- компилируется исполняемый файл `push_test`;
* `push_test.o` - из объектного файла;
* `-L..`        - после **-L** пишем адрес каталога, где находится библиотека (**..** - вышестоящий каталог);
* `-lsieve_dyn` - после **-l** пишется имя библиотеки без префикса **lib** и суффикса **.so**;
* `-Wl`         - обращение к линковщику;
* `-rpath`      - опция линковщика, позволяющая указать дополнительные каталоги для поиска динамических библиотек, во время выполнения программы; 
* `..`          - путь к библиотеке (вышестоящий каталог).

В каталоге `sievelib/` появляется исполняемый файл `push_test`, который можно запустить командой:

`./push_test`

