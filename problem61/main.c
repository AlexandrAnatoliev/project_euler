// main.c - problem 61 (project Euler)
// Цикличные фигурные числа

// К фигурным (многоугольным) числам относятся треугольные, квадратные, пятиугольные, шестиугольные,
// семиугольные и восьмиугольные числа, которые расчитываются по следующим формулам:

// Треугольные	 	P3, n = n(n + 1) / 2	 	1, 3, 6, 10, 15, ...
// Квадратные	 	P4, n = n2	 				1, 4, 9, 16, 25, ...
// Пятиугольные	 	P5, n = n(3n−1) / 2	 		1, 5, 12, 22, 35, ...
// Шестиугольные	P6, n = n(2n−1)	 			1, 6, 15, 28, 45, ...
// Семиугольные	 	P7, n = n(5n−3) / 2	 		1, 7, 18, 34, 55, ...
// Восьмиугольные	P8, n = n(3n−2)	 			1, 8, 21, 40, 65, ...

// Упорядоченное множество из трех четырехзначных чисел : 8128, 2882, 8281,
// обладает тремя интересными свойствами
//
// Множество является цикличным : последние две цифры каждого числа являются первыми двумя цифрами
// следующего(включая последнее и первое числа).
// Каждый тип многоугольника — треугольник(P3, 127 = 8128), квадрат(P4, 91 = 8281)
// и пятиугольник(P5, 44 = 2882) — представлены различными числами данного множества.
// Это — единственное множество четырехзначных чисел, обладающее указанными свойствами.
// Найдите сумму элементов единственного упорядоченного множества из шести цикличных четырехзначных чисел,
// в котором каждый тип многоугольников — треугольник, квадрат, пятиугольник, шестиугольник,
// семиугольник и восьмиугольник — представлены различными числами этого множества.
//

#include <stdio.h>
#include "header.h"
#include "timer.h"
#include "funcs.c"
#include "check.h"

int main(void)
{
	TIMER_START

	CNT_INIT(10) // количество выводимых принтов

	//	инициализация первого узла 4-значным треугольным числом (близким к 1000)
	fig_t triangle_fig;
	get_near_figure(&triangle_fig, 1000);
	node_t *head = node_malloc(&triangle_fig);

	//	добавление и инициализация остальных узлов в список
	//	сохранить первый узел (треугольное число) и последний (восьмиугольное)
	node_t *past = head;
	name_t name = triangle;
	while (name < octagonal)
	{
		name++; // перебираем имена чисел
		fig_t fig_num;
		fig_num.name = name;
		node_t *node = node_malloc(&fig_num); // выделяем под них память
		past = list_add_node(past, node);	  // добавляем в конец списка
	}

	// TODO заменить на past?
	node_t *ptr = head; // указываем на текущее число

	//	пока треугольное число не превысит 9999
	while (head->figure.value < 10000) //	пока треугольное число не превысит 9999
	{
		//	если узел не первый (head != NULL)
		//	и число вышло за диапазон из 100 (меньше (head->value%100) * 100 + 100)
		//		идем влево
		//		увеличиваем число
		//		continue
		if ((ptr->head != NULL) && (ptr->figure.value >= (ptr->head->figure.value % 100) * 100 + 100))
		{
			ptr = ptr->head;
			get_next_figure(&ptr->figure);
			CHECK_SHOW
			continue;
		}

		//		если конец цепочки (next == NULL)
		//			сравнить цифры первого и последнего числа
		//				если совпали break;
		//			иначе
		//				увеличиваем число;
		//				continue
		if (ptr->next == NULL)
		{
			if ((ptr->figure.value % 100) == (head->figure.value / 100))
				break;
			else
			{
				get_next_figure(&ptr->figure);
				CHECK_SHOW
				continue;
			}
		}
		//		если фигурное число заканчивается на 00 - 09
		//			увеличиваем его
		//			continue
		if ((ptr->figure.value % 100) < 10)
		{
			get_next_figure(&ptr->figure);
			CHECK_SHOW
			continue;
		}
		//		если число - фигурное
		//			переходим вправо
		// 			получаем ближайшее
		//			continue
		int next_num = GET_FIGURE(ptr->figure.value, ptr->figure.name);
		if (next_num == ptr->figure.value)
		{
			ptr = ptr->next;
			get_near_figure(&ptr->figure, SHIFT_DIGITS(ptr->head->figure.value));
			CHECK_SHOW
			continue;
		}
	}

	//	вычисление ответа

	// удаление списка и освобождение памяти
	list_free(head);

	TIMER_FINISH
	SHOW_TIME
	// вывод ответа
	return 0;
}